### Learn from Theseus：How Theseus solve this problem
#### **运行时持久的单元**：
Theseus将系统划分为许多小的、有明确边界的组件，称为单元，它们在运行时可以被动态地加载、链接和交换。这种方法可以限制单个漏洞的影响，实现内核子系统的隔离。
#### **语言内部的OS设计**：
Theseus将操作系统的执行环境与Rust语言的运行时模型相匹配，并使用语言级别的机制来实现操作系统的语义。这种设计使编译器能够检查操作系统的安全性和正确性不变量，从而实现与硬件支持相同的子系统隔离效果。
#### **实时演化和故障恢复**：
Theseus利用其结构和语言内部的设计来实现核心操作系统组件的实时更新和容错。这种方法不仅保证了性能，而且达到了更好的扩展性和适用性。



### 1. 

- **Theseus OS 的设计目标和贡献**：
	- Theseus 是一个实验性的操作系统，旨在通过减少组件之间的状态溢出，利用 Rust 语言的安全性和编译器的能力，提高系统的模块化、可演化性和可用性。
- **Theseus OS 的结构和原则** 
	- Theseus 由许多小的、有明确的运行时边界的组件（称为 cells）组成，这些组件可以在运行时进行组合和替换。
	- Theseus 遵循三个设计原则：
		1. 要求所有 cells 有运行时持久的边界；
		2. 最大化语言和编译器的能力；
		3. 最小化 cells 之间的状态溢出。
- **Theseus OS 的启动过程**：
	- Theseus 在链接阶段分割编译过程，将原始的 cell 对象文件直接放入 OS 镜像中，以便在运行时进行链接。
	- Theseus 使用一个由一组静态链接的普通 cells 组成的微型“基础内核”镜像（称为 nano_core）来引导一个最小化的环境，支持虚拟内存和加载/链接对象文件。
	- 在引导的最后阶段，nano_core 完全替换自己，动态地加载其组成的 cells，以满足所有 cells 有运行时持久边界的要求。

### 2.

- **软状态和不可避免的状态**：
	- Theseus的单元(cell)通常保持软状态，即可以在不影响正确性的情况下丢失或丢弃的状态，例如硬件时钟源的缓存。
	- 不可避免的状态是指硬件需要操作系统代为维护的状态，或者是处理异步硬件事件所需的上下文状态。这些状态无法通过不透明导出(opaque exportation)来实现，而且违反了无状态通信(stateless communication)的原则。
- **状态存储设施state_db**：
	- 为了保持单元的可互换性(interchangeability)，Theseus将不可避免的状态分配给一个明确的所有者，并赋予它们静态的生命周期，通过将它们移动到state_db中进行管理。state_db是一个类似于键值数据库的状态存储设施，具有最小的语义。任何单例单元(singleton cell)都可以将其静态状态移动到state_db中，并获得一个弱引用(weak reference)，作为一种软状态。state_db在自身的交换过程中保持可互换性，因为它通过序列化到非易失性存储来硬化自身。另一个类似的单元是单元管理器(cell manager)，它也必须序列化其单元元数据。
- **内在语言性和无状态溢出性的示例**：
	- 作者通过两个子系统的例子进一步说明了内在语言性(intralinguality)设计和无状态溢出性(state spill freedom)之间的关系：内存管理和任务管理。
- **内存管理**：
	- Theseus的MappedPages类型(§4.3)通过不透明导出消除了状态溢出：请求映射的客户端拥有结果的MappedPages对象，而不是创建它的服务器(mm单元)。相比之下，现有的操作系统中的mm实体会在内存映射的元数据中产生状态溢出，例如虚拟内存区域(VMA)的列表或表；客户端必须盲目地信任底层的映射和VMA在使用其虚拟地址句柄期间会持续存在。重要的是，我们认为页表是硬件所需的MMU状态，就像x86的GDT或TSS一样。页表项不是语言级别的对象，也没有持久的变量名绑定；因此，写入页表是一种硬件外部化的副作用，而不是状态溢出。关键的是，这种副作用的状态——从“未映射”到“已映射”的转换——并没有丢失，而是反映在客户端的MappedPages对象中，而不是隐藏在服务器端的状态变化中。
- **任务管理**：
	- Theseus的内在语言设计和其随之而来的不透明导出显著地减少了其任务结构的范围和大小，从而避免了其他子系统向其任务管理单元溢出的状态。这是因为解绑器(unwinder)和编译器一起保留了完全清理任务获取的资源的能力，即使是跨任务共享的资源，也不需要咨询其任务结构中的资源记账状态。Theseus还将与其他操作系统特性相关的任务相关状态，例如运行队列和调度器信息，从任务结构中移出，并移入这些组件本身。这比传统的操作系统更符合关注点分离的原则，后者将为手动资源记账和任务清理而需要的大量操作系统状态堆积到一个集中的、包罗万象的任务结构中。这样的任务结构设计导致了许多操作系统操作向任务管理实体溢出状态，并导致交叉依赖，使实体紧密地纠缠在一起，阻碍了它们的演化或恢复。因此，Theseus的任务结构只包含最基本的必需品，例如任务的运行状态、栈和保存的执行上下文（寄存器值）。相应地，它排除了打开的文件、打开的套接字、内存映射、等待队列等列表。

### 3. 高级语言编写 POSIX 内核的利弊

- **高级语言编写 POSIX 内核的利弊**：
	作者比较了用 Rust 和 C 语言实现的两个内核，Theseus 和 Linux，分析了高级语言在安全性、可靠性、性能和兼容性方面的优劣。
	- **安全性**：
		- Rust 语言的内存安全和类型安全特性可以避免许多常见的内核错误，如空指针解引用、缓冲区溢出、内存泄漏等。这些错误在 C 语言中很难检测和修复，且可能导致安全漏洞和系统崩溃。
	- **可靠性**：
		- Rust 语言的模块化和抽象特性可以支持内核的在线更新和故障恢复，而不需要重启或停止服务。这些特性在 C 语言中很难实现，且可能引入额外的复杂性和开销。
	- **性能**：
		- Rust 语言的零成本抽象和编译时优化特性可以保证高级语言编写的内核与 C 语言编写的内核具有相近甚至更好的性能。这些特性在 C 语言中需要手动优化或依赖编译器的支持。
	- **兼容性**：
		- Rust 语言的跨平台和互操作特性可以保证高级语言编写的内核与 C 语言编写的内核具有良好的兼容性。这些特性在 C 语言中需要考虑不同的硬件和软件环境或使用特定的接口和协议。

### 4. Theseus OS 的未来发展

- **Theseus OS 的未来发展**：
	作者讨论了 Theseus OS 的未来发展方向，包括进一步提高系统的模块化、可演化性和可用性，以及探索新的系统设计和编程模型。
	- **模块化**：
		- 作者计划通过引入更多的运行时持久的细胞，以及通过改进细胞的组合和交换机制，来进一步提高 Theseus 的模块化。这将使 Theseus 能够更灵活地适应不同的硬件和软件环境，以及更有效地利用硬件和软件的资源。
	- **可演化性**：
		- 作者计划通过引入更多的语言内部的 OS 设计，以及通过改进状态管理和故障恢复机制，来进一步提高 Theseus 的可演化性。这将使 Theseus 能够更快地响应新的需求和挑战，以及更好地恢复和适应系统的故障和变化。
	- **可用性**：
		- 作者计划通过引入更多的用户友好的接口和工具，以及通过改进系统的性能和兼容性，来进一步提高 Theseus 的可用性。这将使 Theseus 能够更好地满足用户的需求和期望，以及更好地与其他系统和应用程序协同工作。
	- **新的系统设计和编程模型**：
		- 作者计划通过引入更多的研究和实验，以及通过改进系统的理论和实践，来探索新的系统设计和编程模型。这将使 Theseus 能够更好地理解和利用计算机的潜力，以及更好地推动计算机科学和工程的发展。

### 5. Theseus OS 的实验结果

- **Theseus OS 的实验结果**：
	作者通过一系列的实验，评估了 Theseus OS 的性能、可用性和可演化性。实验结果显示，Theseus OS 在许多方面都优于传统的 C 语言编写的内核，如 Linux 和 FreeBSD。
	- **性能**：
		- 实验结果显示，Theseus OS 的性能与 Linux 和 FreeBSD 相当，甚至在某些方面更好。例如，Theseus OS 的启动时间、内存使用和 I/O 吞吐量都优于 Linux 和 FreeBSD。这主要归功于 Theseus OS 的模块化设计和 Rust 语言的零成本抽象。
	- **可用性**：
		- 实验结果显示，Theseus OS 的可用性也优于 Linux 和 FreeBSD。例如，Theseus OS 的故障恢复时间、系统更新时间和用户体验都优于 Linux 和 FreeBSD。这主要归功于 Theseus OS 的可演化设计和 Rust 语言的内存安全。
	- **可演化性**：
		- 实验结果显示，Theseus OS 的可演化性远优于 Linux 和 FreeBSD。例如，Theseus OS 可以在运行时更新和替换其细胞，而不需要重启或停止服务。这主要归功于 Theseus OS 的细胞设计和 Rust 语言的模块化。
	作者总结说，Theseus OS 的实验结果证明了高级语言编写的内核的潜力，以及 Theseus OS 的设计目标和贡献。作者希望 Theseus OS 能够推动操作系统的发展，以及计算机科学和工程的研究。

### 6. 实现核心OS组件的实时演化和容错恢复

- **实时演化**：
	- Theseus可以在不停机或丢失执行上下文的情况下，动态替换任何单元，包括内核级别的单元，以更新或修复其功能。这是通过单元交换机制实现的，该机制利用单元的运行时边界和元数据，以及Rust的所有权和生命周期模型，来保证交换的安全性和正确性。
- **容错恢复**：
	- Theseus可以在软件或硬件故障发生时，恢复受影响的单元，而不影响其他正常运行的单元。这是通过单元重启机制实现的，该机制利用单元的类型信息和依赖关系，以及Rust的异常处理和展开机制，来保证恢复的完整性和一致性。
- **案例研究**：
	- 作者展示了Theseus在不同场景下的实时演化和容错恢复能力，例如联合应用-内核演化，微内核级别组件的演化和恢复，以及对抗硬件故障的恢复。作者还与MINIX 3进行了比较，显示Theseus在可用性方面的优势。

### 7. Theseus 操作系统的内存管理和任务管理的设计和实现

- **内存管理**：
	- Theseus 使用 MappedPages 类型来表示一段映射的内存区域，它可以保证在编译时检查内存安全性和隔离性，防止无效的页错误和数据泄露。MappedPages 类型提供了一些方法来安全地访问其底层的内存内容，例如 as_type() 和 as_slice()。MappedPages 类型还可以根据内存区域的属性，分为 MappedPagesMut 和 MappedPagesExec，分别用于可变和可执行的内存区域。
- **任务管理**：
	- Theseus 的任务管理中心是一组泛型函数，它们使用一致的类型参数来处理任务生命周期的各个阶段，例如 spawn_task()，task_wrapper()，task_cleanup_success() 等。这些函数可以保证任务的类型信息（函数，参数，返回类型）在整个生命周期中不会丢失。Theseus 不提供 fork() 这样的不安全和不适合 SAS 系统的功能，而是使用自己的任务抽象，避免了标准库的不足。

### 8. Theseus的内存管理设计

- Theseus使用MappedPages类型来表示虚拟内存，它可以保证一对一的映射关系，避免了内存别名和使用后释放的问题。
- MappedPages提供了安全的访问接口，如as_type()和as_slice()，它们可以检查内存区域的边界，并将内存区域的生命周期绑定到返回的引用上。
- MappedPages实现了Drop trait，以便在对象离开作用域或异常退出时自动释放和取消映射内存区域。
- MappedPages还有专门的类型，如MappedPagesMut和MappedPagesExec，用于表示可变或可执行的内存区域。